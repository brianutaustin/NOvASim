//***** Generated by Geant4 Geometry Editor at  Fri Oct 28 17:12:28 CDT 2005 *****

//------HeaderFile-
#include "novaGeometry.hh"
#include "WLSfiber.hh"
#include "G4UnitsTable.hh"
#include "NOVAstrip.hh"
#include "G4VUserDetectorConstruction.hh"
#include "globals.hh"
#include "G4Material.hh"
#include "G4MaterialTable.hh"
#include "G4Element.hh"
#include "G4ElementTable.hh"
#include "G4Box.hh"
#include "G4Tubs.hh"
#include "G4Torus.hh"
#include "G4LogicalVolume.hh"
#include "G4ThreeVector.hh"
#include "G4PVPlacement.hh"
#include "G4PVReplica.hh"
#include "G4SDManager.hh"
#include "G4VisAttributes.hh"
#include "G4Colour.hh"
#include "G4MaterialTable.hh"
#include "G4LogicalBorderSurface.hh"
#include "G4OpBoundaryProcess.hh"
#include "fstream"
#include "iostream"
#include "G4RunManager.hh"
#include "novaRunAction.hh"
#include "G4SystemOfUnits.hh"
#include "G4PhysicalConstants.hh"

novaGeometry::novaGeometry()
{ ; }
novaGeometry::~novaGeometry()
{ 
  //  if (green){ delete green; green = 0; }
  ;

 }
G4VPhysicalVolume* novaGeometry::Construct( )
{
  
  // Materials from Scratch
  //  G4Material* Vacuum;
  Vacuum = new G4Material ("Vacuum", 1., 1.01*g/mole,universe_mean_density, kStateGas, 3.e-18*pascal,2.73*kelvin);
 
  G4int scintEntries = 0;
  G4double scintEnergy[500];
  G4double scintEmit[500];
  G4double vacIndex[500];
  G4double vacAbsorb[500];
  G4double pWavelength;
  //  G4double scintIndexconst = 1.58;
  G4double vacAbsorbconst = 100*m;

  ifstream ReadScint;
  ReadScint.open("pl_file_1.dat");
  while(!ReadScint.eof()){
    G4String filler;
    ReadScint >> pWavelength >> filler >> scintEmit[scintEntries];
    scintEnergy[scintEntries] = (1240/pWavelength)*eV; //convert wavelength to eV
    //    scintIndex[scintEntries]=scintIndexconst;
    //    scintSlow[scintEntries]=0;
    vacIndex[scintEntries] = 1;
    vacAbsorb[scintEntries] = vacAbsorbconst;
    scintEntries++;
  }

  //  G4MaterialPropertiesTable *vacMPT;
  vacMPT = new G4MaterialPropertiesTable();
  vacMPT->AddProperty("RINDEX",scintEnergy,vacIndex,scintEntries);
  vacMPT->AddProperty("ABSLENGTH",scintEnergy,vacAbsorb,scintEntries);
  Vacuum->SetMaterialPropertiesTable(vacMPT);

  invis = new G4VisAttributes( G4Colour(255/255. ,255/255. ,255/255. ));
  invis->SetVisibility(false);
  black = new G4VisAttributes(G4Colour(0,0,0)); 
  green = new G4VisAttributes(G4Colour(0,1,0)); 
  
  thestrip = new NOVAstrip("NOVA.cfg");
  stripmodule = thestrip->GetModule();

  numfibers = thestrip->GetNumFibers();
  fiberradius = thestrip->GetFibRadius();
  fiblength = thestrip->GetFibLength();
  paintthickness = thestrip->GetPaintThickness();
  stripheight = thestrip->GetStripHeight();
  stripwidth = thestrip->GetStripWidth();
  curve_radius = thestrip->GetCurveRadius();  
  off_axis_dist = thestrip->GetOffAxisDist();


  G4RotationMatrix DontRotate;   
  G4double zero_deg = 0.0*deg;   
  DontRotate.rotateX(zero_deg);  
  
  //  keep this to check the size of the holder
  //  G4Box *s_holder;
  //  s_holder = new G4Box("s_holder",stripwidth/2+paintthickness+1*mm,stripheight/2+paintthickness+1*mm,fiblength/2 + 2.5*cm);
  
  //  G4LogicalVolume *l_holder;
  //  l_holder = new G4LogicalVolume(s_holder,Vacuum,"l_holder",0,0,0);
  //  l_holder->SetVisAttributes(invis);

  //logical world volume
  G4Box *s_world = new G4Box("s_world", stripwidth/2 + 5*cm, stripheight/2 + 5*cm, fiblength/2 + curve_radius + 110*cm );

  G4LogicalVolume *l_world;
  l_world = new G4LogicalVolume(s_world, 	 
				Vacuum, 		 
				"l_world",		 
				0,0,0);
  
  l_world->SetVisAttributes(invis);
  
  //  then use this for (only) the visualization
  //  G4VPhysicalVolume *p_holder;
  //  p_holder=new G4PVPlacement(G4Transform3D(DontRotate,G4ThreeVector(0,0,0)),l_holder,"p_holder",l_world,true,0);
  //  l_holder->SetVisAttributes(green);
  
  G4RotationMatrix rotMatrixp_world; 
  G4double anglep_world = 0.0*deg;  
  rotMatrixp_world.rotateX(anglep_world); 
  
  G4RotationMatrix Rotate; 
  G4double angle = 270.0*deg; 
  Rotate.rotateX(angle);
  Rotate.rotateZ(90.0*deg); 
  
  G4Tubs *s_PMT;
  s_PMT = new G4Tubs("s_PMT", 0, fiberradius, 0.5*mm, 0, twopi*rad);
  l_PMT = new G4LogicalVolume(s_PMT, Vacuum,"l_PMT", 0, 0, 0);
  
  blue = new G4VisAttributes( G4Colour(0/255. ,0/255. ,255/255. ));
  
  l_PMT->SetVisAttributes(black);

  G4VPhysicalVolume* p_world;
  p_world = new G4PVPlacement(G4Transform3D(rotMatrixp_world,	//rotation 
								 G4ThreeVector(0.0*mm, 0.0*mm, 0.0*mm)),
						   "p_world",   //its name  (2nd constructor)
						   l_world,         //its logical volume 
						   NULL,              //its mother volume 
						   false,                 //no boolean operation 
						   0);                       //copy number 
  
  
  //physical NOvA module 
  G4VPhysicalVolume* p_stripmodule;
  p_stripmodule = new G4PVPlacement(G4Transform3D
				    (rotMatrixp_world,
				     G4ThreeVector(0,0,0)),stripmodule,"p_stripmodule",l_world,false,0);
  
  G4int PMTcount = 0; 

  // real nova
  //  p_PMT1 = new G4PVPlacement(G4Transform3D(rotMatrixp_world,G4ThreeVector(off_axis_dist,curve_radius,-800*cm + 4*curve_radius -0.5*mm)),l_PMT,"p_PMT1",l_world,true,0);


  // for Landon's stuff (1.0 m length)  works with 123 cm fiber length
  //         p_PMT1 = new G4PVPlacement(G4Transform3D(rotMatrixp_world,G4ThreeVector(off_axis_dist,curve_radius,-69.1*cm + 4*curve_radius -0.5*mm)),l_PMT,"p_PMT1",l_world,true,0);


       p_PMT1 = new G4PVPlacement(G4Transform3D(rotMatrixp_world,G4ThreeVector(off_axis_dist,curve_radius,-169.1*cm + 4*curve_radius -0.5*mm)),l_PMT,"p_PMT1",l_world,true,0);
   PMTcount++;
   
   //real nova
   //   p_PMT2 = new G4PVPlacement(G4Transform3D(rotMatrixp_world,G4ThreeVector(off_axis_dist,-curve_radius,-800*cm + 4*curve_radius -0.5*mm)),l_PMT,"p_PMT2",l_world,true,0);  

   // for Landon's stuff
   //            p_PMT2 = new G4PVPlacement(G4Transform3D(rotMatrixp_world,G4ThreeVector(off_axis_dist,-curve_radius,-69.1*cm + 4*curve_radius -0.5*mm)),l_PMT,"p_PMT2",l_world,true,0);  
   p_PMT2 = new G4PVPlacement(G4Transform3D(rotMatrixp_world,G4ThreeVector(off_axis_dist,-curve_radius,-169.1*cm + 4*curve_radius -0.5*mm)),l_PMT,"p_PMT2",l_world,true,0);


   PMTcount++;

  G4cout<<PMTcount<<" PMTs were counted."<<G4endl;
  //give number of PMTs to the RunAction for statistics compilation
  G4RunManager *runman=G4RunManager::GetRunManager();
  novaRunAction *runac=(novaRunAction*)runman->GetUserRunAction();
  runac->SetNumPMTs(PMTcount);
  
  //Optical properties of PMTs
  G4int PMTentries = 0;
  G4double PMTenergy[500];
  G4double PMTindex[500];
  G4double PMTreflect[500];
  G4double PMTdetect[500];
  G4double indexconst = 1.49;
  G4double reflectconst = 0.0;
  //  G4double detect = 1;
  ifstream ReadPMT;
    ReadPMT.open("qe_file_2.dat"); // M16
    // ReadPMT.open("apd_qe_1.dat");
  
  while(!ReadPMT.eof()){
    G4String filler;
    G4double wavelength;
    ReadPMT>>wavelength>>filler>>PMTdetect[PMTentries];
    PMTdetect[PMTentries]= 0.95*PMTdetect[PMTentries];
    PMTenergy[PMTentries]=(1240/wavelength)*eV;
    PMTindex[PMTentries] = indexconst;
    PMTreflect[PMTentries] = reflectconst;
    PMTentries++;
  }

  ReadPMT.close();

  opt_pmt = new G4OpticalSurface("opt_pmt");
  opt_pmt->SetModel(glisur);
  opt_pmt->SetFinish(polished);
  opt_pmt->SetType(dielectric_metal);

  pmtMPT = new G4MaterialPropertiesTable();
  pmtMPT->AddProperty("EFFICIENCY",PMTenergy,PMTdetect,PMTentries);
  pmtMPT->AddProperty("REFLECTIVITY",PMTenergy,PMTreflect,PMTentries);
  pmtMPT->AddProperty("RINDEX",PMTenergy,PMTindex,PMTentries);
  opt_pmt->SetMaterialPropertiesTable(pmtMPT);
  skin_pmt = new G4LogicalSkinSurface("skin_pmt",l_PMT,opt_pmt);
  
  return p_world;
}
